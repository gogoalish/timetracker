// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tasks.sql

package repo

import (
	"context"
	"database/sql"
	"time"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (user_id, description, created_at) VALUES ($1, $2, $3)
RETURNING id
`

type CreateTaskParams struct {
	UserID      int32     `json:"user_id"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createTask, arg.UserID, arg.Description, arg.CreatedAt)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getOrderedTasksByUserID = `-- name: GetOrderedTasksByUserID :many
SELECT id, user_id, description, start_dt, end_dt, created_at, CAST(EXTRACT(HOUR from end_dt - start_dt) AS INT) AS hours, 
    CAST(EXTRACT(MINUTE from end_dt - start_dt) AS INT) as minutes  FROM tasks 
WHERE user_id = $1 AND 
start_dt >= $2 AND
end_dt <=  $3 
GROUP BY id ORDER BY hours DESC
`

type GetOrderedTasksByUserIDParams struct {
	UserID  int32        `json:"user_id"`
	StartDt sql.NullTime `json:"start_dt"`
	EndDt   sql.NullTime `json:"end_dt"`
}

type GetOrderedTasksByUserIDRow struct {
	ID          int32        `json:"id"`
	UserID      int32        `json:"user_id"`
	Description string       `json:"description"`
	StartDt     sql.NullTime `json:"start_dt"`
	EndDt       sql.NullTime `json:"end_dt"`
	CreatedAt   time.Time    `json:"created_at"`
	Hours       int32        `json:"hours"`
	Minutes     int32        `json:"minutes"`
}

func (q *Queries) GetOrderedTasksByUserID(ctx context.Context, arg GetOrderedTasksByUserIDParams) ([]GetOrderedTasksByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderedTasksByUserID, arg.UserID, arg.StartDt, arg.EndDt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderedTasksByUserIDRow{}
	for rows.Next() {
		var i GetOrderedTasksByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Description,
			&i.StartDt,
			&i.EndDt,
			&i.CreatedAt,
			&i.Hours,
			&i.Minutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, user_id, description, start_dt, end_dt, created_at FROM tasks WHERE id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, id int32) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Description,
		&i.StartDt,
		&i.EndDt,
		&i.CreatedAt,
	)
	return i, err
}

const setTaskEndDate = `-- name: SetTaskEndDate :exec
UPDATE tasks SET end_dt = $1 WHERE id = $2
`

type SetTaskEndDateParams struct {
	EndDt sql.NullTime `json:"end_dt"`
	ID    int32        `json:"id"`
}

func (q *Queries) SetTaskEndDate(ctx context.Context, arg SetTaskEndDateParams) error {
	_, err := q.db.ExecContext(ctx, setTaskEndDate, arg.EndDt, arg.ID)
	return err
}

const setTaskStartDate = `-- name: SetTaskStartDate :exec
UPDATE tasks SET start_dt = $1 WHERE id = $2
`

type SetTaskStartDateParams struct {
	StartDt sql.NullTime `json:"start_dt"`
	ID      int32        `json:"id"`
}

func (q *Queries) SetTaskStartDate(ctx context.Context, arg SetTaskStartDateParams) error {
	_, err := q.db.ExecContext(ctx, setTaskStartDate, arg.StartDt, arg.ID)
	return err
}
